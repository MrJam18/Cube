<p>Задание 1:</p>
<p>запустить ./run.sh</p>
<p>список погоды на /weather/list</p>
<p>список отзывов на /reviews/list</p>
<p>список пользователей на /users/list</p>
<p>Задание 2: </p>
<p>JOIN - </p>

```
SELECT title AS 'book_title',
       GROUP_CONCAT(full_name SEPARATOR ', ') as 'author_names',
       COUNT(author_id) as 'authors_count'
        FROM books
        LEFT JOIN book_to_author ON books.id = book_to_author.book_id
        LEFT JOIN authors ON book_to_author.author_id = authors.id
        GROUP BY books.id ORDER BY authors_count;
```
<p>
Вложенные запросы -

```
SELECT title AS 'book_title', authors_groups.author_names, authors_groups.authors_count
    FROM books,
    (SELECT book_id,
        GROUP_CONCAT(full_name SEPARATOR ', ') as 'author_names',
        COUNT(*) as 'authors_count'
        FROM book_to_author, authors
        WHERE book_to_author.author_id = authors.id
        GROUP BY book_to_author.book_id) AS authors_groups
    WHERE authors_groups.book_id = books.id
    ORDER BY authors_groups.authors_count;
```

</p>
<p>
Хотя изначально вложенные запросы кажутся более интуитивно понятными, все же с усложнением запроса, его читаемость снижается, также падает и производительность. Кроме того, хотя и не должно быть такой ситуации, когда у автора не может быть автора, однако в случае с вложенным запросом, пришлось бы добавлять дополнительную логику (запрос) для отображения этих книг без авторов. Всегда, когда можно переписать вложенный запрос на join, особенно в ситуации когда обращаемся к таблице (таблицам) с большим количеством данных, стоит это сделать для улучшения производительности и улучшения читабельности. Так как все современные СУБД настроены на JOIN, то производительность данных запросов куда лучше. Иногда даже сама СУБД (PostgreSQL к примеру) под капотом переписывает вложенные запросы на запросы с использованием JOIN. Однако, иногда без вложенных запросов не обойтись, например для использования GROUP BY или для агрегации и иных сложных запросов. Также некоторые фреймворки конечно иногда не используют join (потому что отдельные запросы дают куда больше гибкости) в системах с Active Record (например Laravel), из-за этого возникают трудности, и иногда для выполнения задания в срок проще написать со встроенным в фреймворк функционалом, хотя конечно, потом это все можно доделать.
</p>
<p>Задание 3:</p>
<p>1. обжарить 4 котлеты с одной стороны, это 1 минута;</p>
<p>2. две котлеты снять (они обжарены с одной стороны), две перевернуть, и добавить ещё две сырые, пожарить этот набор, это ещё 1 минута;</p>
<p>3. снять две готовые котлеты, перевернуть две, которые обжарены только с одной стороны, и добавить те две снятые, это ещё 1 минута.</p>
<p>В итоге получается 3 минуты</p>